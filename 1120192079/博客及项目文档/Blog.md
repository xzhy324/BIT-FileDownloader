# 0. PSP表格

| PSP2.1                                  | Personal Software Process Stages        | 预估耗时（分钟） | 实际耗时（分钟） |
| --------------------------------------- | --------------------------------------- | ---------------- | ---------------- |
| **Planning**                            | **计划**                                | **20**           | 20               |
| · Estimate                              | · 估计这个任务需要多少时间              | 20               | 20               |
| **Development**                         | **开发**                                | **1010**         |                  |
| · Analysis                              | · 需求分析 (包括学习新技术)             | 300              | 600              |
| · Design Spec                           | · 生成设计文档                          | 30               |                  |
| · Design Review                         | · 设计复审 (和同事审核设计文档)         | 30               |                  |
| · Coding Standard                       | · 代码规范 (为目前的开发制定合适的规范) | 20               |                  |
| · Design                                | · 具体设计                              | 180              |                  |
| · Coding                                | · 具体编码                              | 120              |                  |
| · Code Review                           | · 代码复审                              | 30               |                  |
| · Test                                  | · 测试（自我测试，修改代码，提交修改）  | 300              |                  |
| **Reporting**                           | **报告**                                | **90**           |                  |
| · Test Report                           | · 测试报告                              | 40               |                  |
| · Size Measurement                      | · 计算工作量                            | 20               |                  |
| · Postmortem & Process Improvement Plan | · 事后总结, 并提出过程改进计划          | 30               |                  |
|                                         | **合计**                                | **1120**         |                  |

# 1. 解题思路描述

> 2022-1-9 20:51 ~ 23:30
>
> 解题思路描述。即刚开始拿到题目后，如何思考，如何找资料的过程。（3‘）

### 第一阶段思路

拿到文件下载助手的选题，`实现一个可以并发下载文件的软件`，初步判断有以下功能需求

1. 单文件下载
2. 单文件分块多线程下载
3. 多文件下载
5. 使用参数指定
   1. 文件下载地址
   2. 并发线程数
   3. 文件存放地址

考虑到非过程化的功能较多，为了方便功能的快速开发，采用python作为开发语言

文件下载的核心功能由requests库中的get实现

多线程的分段下载，使用http请求头 Range 对文件进行分段下载

参数指定是一个单独的模块，经过资料查阅，有两种解决方案

1. argsparser
2. click

由于python自带的argsparser功能较为单一，采用click包作为最终的模块选择

多线程涉及调试的问题，采用python自带的logging库进行基于日志的调试

多线程本身采用multithreading库实现，对于每一线程所下载的内容，还应该检查ETag（最近修改标志）

最后由于没有断点续传的需求，未添加ETAG和临时配置文件的机制



综上，需要学习或者观看项目文档的内容是，

1. requests库 ， get部分

2. click包的使用

3. http请求头中Range和Etag的作用（aborted）

4. 日志调试的基本技巧

5. python的多线程编程，multithreading库

   > 最后采用了python标准库中的concurrency.futures库，原因是因为该库封装了multithreading库，没有后者那么底层，使用简便
   >
   > [concurrent.futures --- 启动并行任务 — Python 3.10.2 文档](https://docs.python.org/zh-cn/3/library/concurrent.futures.html)
   
6. 

### 第二阶段思路









# 2. 设计实现过程

> 设计包括代码如何组织，比如会有几个类，几个函数，他们之间关系如何，关键函数是否需要画出流程图？单元测试是怎么设计的？（5‘）





# 3.程序性能与改进过程

> 记录在改进程序性能上所花费的时间，描述你改进的思路，并展示一张性能分析图（如使用Visual Studio的性能分析工具自动生成），并展示你程序中消耗最大的函数。（3‘）

# 4.代码说明

> 展示出项目关键代码，并解释思路与注释说明。（3‘）



# 5. 开发日志



## 第一阶段

### 1月13日

1. 学习了python日志包的用法（logging module），将关键代码处添加了日志输出
2. 删去了with as结构，将try catch要完成的功能简化成日志的报错
3. 了解了存储单位（b-B-KB- e.t.c.）和传输速率单位（bit per second (bps) - 1Kbps（1Kb）- 1Mbps -e.t.c.）之间的进制区别 （1024 versus 1000），并且修改了下载进度条 tqdm组件的参数，使其满足存储单位以及对应的进制
4. 学习了python中可变参数列表 *args 以及 **kwargs的用法，他们分别对应一个列表和一个指定了关键字的元组

### 1月14日

1. 学习了plantUML的绘图语法，使用语雀绘制了关键的下载函数的流程图
2. 添加了requirement.txt
3. 学习了三种python并发编程模块concurrent.futures，threading，multithreading库之间的区别，决定采用封装程度较高的concurrent.futures进行多线程并发下载
4. 增加了dev文件，用于管理小的改动和测试
5. [dev]将配置文件独立成txt，每次加载脚本时读取，方便调试

### 1月15日

1. 增加了计时模块和多线程下载模块
   1. 多线程下载模块添加了对磁盘的互斥读写锁
   2. 多线程下载
2. 学习了python函数之间的变量传递方式
3. 学习了open函数的各个模式，并决定对于顺序下载，采用wb模式，对于多线程下载，采用rb+模式



> 关键思路记录：
>
> ​	对于单线程下载，若文件过大，可以采用流式传输，即多次从内存写到外存，从而能够下载大于内存大小的文件
>
> ​	而在多线程下载中，如果每个线程仍采用流式传输后分段多次写外存的情况，则读写锁请求过于频繁（每个线程下载过程中多次请求），也许设计一种更好的互斥锁结构能够解决这个问题，TBA

### 1月16日

1. 学习了bat脚本的基本书写方法，写了一个可以自动运行python测试用例的测试脚本
   1. `test_case.bat`包含三个测试用例
   2. `test_case_mini.bat`包含一个测试用例
2. 将之前的`开发日志.md`整合到根`blog.md`下
3. 将headers的请求策略更改为二次请求，以判断是否能支持多线程下载
4. 使用tqdm在每个线程下载完成时，更新进度条       
5. 测试了dev文件，通过两个测试脚本       
6. 解决时间不能够正常显示的bug
   1. 关于python `if _name ==__main__`的深入理解，模块调用顺序



## 第二阶段                                  

### 2月7日

1. 整理第二阶段的需求
2. 增加了批量url下载的功能，重构了下载函数，将enrty()函数简化为任务分发函数，二级功能移入startSingleTask()
3. 测试通过了批量url下载功能
4. 搜集了正则表达式资料，最终确定使用strgen包来实现表达式生成目标地址集

### 2月8日

1. 独立出博客及文档文件夹，着手绘制关键函数的说明图
2. 添加了gitignore文件
3. 完成了ftp下载功能
   * 遇见错误：在函数修饰器装饰的函数内调用input()时报错，去掉括号
4. 明确了剩余任务
   1. 完成ftp，正则表达式的支持
   2. 制作gui界面
   3. 性能分析（整合到blog内）
   4. 单元测试（test_case.bat + 测试文档）
   5. 集成测试（测试文档）
   6. 运行说明（如何编译程序 + 如何运行程序 +运行环境要求）
   6. 设计说明书
   6. 测试文档
   6. 博客

### 2月9日

1. 学习了PyQt6的使用，利用QtDesigner绘制了前端界面并生成了代码

   > 由于使用Qt编写，且将所有的前端控件包装成父窗体MainForm的子类，实际功能的实现通过向子界面类传递父类指针来访问相应的槽函数，实现了视图层(View)和控制层(Control)的分离
   >
   > 小优化：由网上教程中主窗口双继承，改进到 单继承并且全部 ui 初始化到 self.ui 更清爽点，解决了命名空间的污染
   >
   > 此外，对于剪切板功能的实现，通过信号-槽在每次窗口被激活在前端时，访问剪切板内容并判断

2. 重构了downloader文件，将关键函数功能独立出来

   * 命令行版本使用entry()入口来分发不同的需求（单链接/多链接/ftp），这在直接调用downloader.py时由__main__入口决定
   * gui版本调用封装好的start_single_task来完成基本的多线程下载功能



### 2月10日

1. 完成测试文档以及单元测试+集成测试
2. 完成设计实现过程以及解题思路的描述

### 2月11日

1. 完善了第二阶段的测试用例以及修复了一些bug
2. 增加了运行说明，完善了部分文档
3. 解决了click修饰的函数内无法使用标准库中input函数的问题
